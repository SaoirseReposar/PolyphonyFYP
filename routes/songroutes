// routes/songRoutes.js - Song and Lyrics API Routes
const express = require('express');
const router = express.Router();
const db = require('../database');
const translationService = require('../services/translationService');
const spotifyService = require('../services/spotifyService');

/**
 * GET /api/songs - Get all songs
 */
router.get('/songs', async (req, res) => {
    try {
        const result = await db.query(
            'SELECT * FROM songs ORDER BY created_at DESC'
        );
        res.json({ success: true, songs: result.rows });
    } catch (error) {
        console.error('Error fetching songs:', error);
        res.status(500).json({ success: false, error: 'Failed to fetch songs' });
    }
});

/**
 * GET /api/songs/:id - Get a single song with lyrics
 */
router.get('/songs/:id', async (req, res) => {
    try {
        const { id } = req.params;
        
        // Get song info
        const songResult = await db.query(
            'SELECT * FROM songs WHERE id = $1',
            [id]
        );
        
        if (songResult.rows.length === 0) {
            return res.status(404).json({ success: false, error: 'Song not found' });
        }
        
        // Get lyrics
        const lyricsResult = await db.query(
            'SELECT * FROM lyrics WHERE song_id = $1 ORDER BY line_number',
            [id]
        );
        
        const song = songResult.rows[0];
        song.lyrics = lyricsResult.rows;
        
        res.json({ success: true, song });
    } catch (error) {
        console.error('Error fetching song:', error);
        res.status(500).json({ success: false, error: 'Failed to fetch song' });
    }
});

/**
 * POST /api/songs - Create a new song
 */
router.post('/songs', async (req, res) => {
    try {
        const { title, artist, language, difficulty, spotify_track_id } = req.body;
        
        // Get Spotify track info
        let spotifyData = null;
        if (spotify_track_id) {
            spotifyData = await spotifyService.getTrackInfo(spotify_track_id);
        }
        
        const result = await db.query(
            `INSERT INTO songs (title, artist, language, difficulty, spotify_track_id, duration_ms, album_art_url)
             VALUES ($1, $2, $3, $4, $5, $6, $7)
             RETURNING *`,
            [
                title,
                artist,
                language,
                difficulty,
                spotify_track_id,
                spotifyData?.duration_ms || null,
                spotifyData?.album_art || null
            ]
        );
        
        res.json({ success: true, song: result.rows[0] });
    } catch (error) {
        console.error('Error creating song:', error);
        res.status(500).json({ success: false, error: 'Failed to create song' });
    }
});

/**
 * POST /api/songs/:id/lyrics - Add lyrics to a song (with auto-translation)
 */
router.post('/songs/:id/lyrics', async (req, res) => {
    try {
        const { id } = req.params;
        const { lyrics } = req.body; // Array of { line_number, timestamp_ms, text }
        
        // Get song to know source language
        const songResult = await db.query('SELECT language FROM songs WHERE id = $1', [id]);
        if (songResult.rows.length === 0) {
            return res.status(404).json({ success: false, error: 'Song not found' });
        }
        
        const sourceLang = songResult.rows[0].language;
        
        // Extract all text for batch translation
        const textsToTranslate = lyrics.map(l => l.text);
        
        // Translate all lines in batch (more efficient than one-by-one)
        console.log(`Translating ${textsToTranslate.length} lines from ${sourceLang} to English...`);
        const translations = await translationService.translateBatch(textsToTranslate, sourceLang, 'EN-US');
        
        // Insert lyrics with translations
        const insertedLyrics = [];
        for (let i = 0; i < lyrics.length; i++) {
            const lyric = lyrics[i];
            const translation = translations[i];
            
            const result = await db.query(
                `INSERT INTO lyrics (song_id, line_number, timestamp_ms, original_text, translated_text, language_to)
                 VALUES ($1, $2, $3, $4, $5, $6)
                 ON CONFLICT (song_id, line_number) 
                 DO UPDATE SET 
                    timestamp_ms = EXCLUDED.timestamp_ms,
                    original_text = EXCLUDED.original_text,
                    translated_text = EXCLUDED.translated_text
                 RETURNING *`,
                [id, lyric.line_number, lyric.timestamp_ms, lyric.text, translation, 'en']
            );
            
            insertedLyrics.push(result.rows[0]);
        }
        
        res.json({ 
            success: true, 
            message: `${insertedLyrics.length} lyrics added and translated`,
            lyrics: insertedLyrics 
        });
    } catch (error) {
        console.error('Error adding lyrics:', error);
        res.status(500).json({ success: false, error: 'Failed to add lyrics', details: error.message });
    }
});

/**
 * POST /api/translate/word - Translate a single word
 */
router.post('/translate/word', async (req, res) => {
    try {
        const { word, language, sentence } = req.body;
        
        // Clean the word (remove punctuation)
        const cleanWord = word.toLowerCase().replace(/[.,!?;¿¡]/g, '').trim();
        
        // Check if translation exists in cache
        const cacheResult = await db.query(
            `SELECT * FROM word_translations 
             WHERE word = $1 AND source_language = $2 AND target_language = 'en'`,
            [cleanWord, language]
        );
        
        if (cacheResult.rows.length > 0) {
            // Update usage count
            await db.query(
                'UPDATE word_translations SET usage_count = usage_count + 1 WHERE id = $1',
                [cacheResult.rows[0].id]
            );
            
            return res.json({ 
                success: true, 
                translation: cacheResult.rows[0],
                cached: true 
            });
        }
        
        // Translate word
        const translationData = await translationService.translateWord(
            cleanWord, 
            language, 
            sentence,
            'EN-US'
        );
        
        // Store in cache
        const insertResult = await db.query(
            `INSERT INTO word_translations (word, source_language, target_language, translation, context)
             VALUES ($1, $2, $3, $4, $5)
             RETURNING *`,
            [cleanWord, language, 'en', translationData.translation, translationData.context]
        );
        
        res.json({ 
            success: true, 
            translation: insertResult.rows[0],
            cached: false 
        });
    } catch (error) {
        console.error('Error translating word:', error);
        res.status(500).json({ success: false, error: 'Failed to translate word' });
    }
});

/**
 * POST /api/words/save - Save a word to user's vocabulary
 */
router.post('/words/save', async (req, res) => {
    try {
        const { user_id, word_id, song_id } = req.body;
        
        const result = await db.query(
            `INSERT INTO user_saved_words (user_id, word_id, song_id)
             VALUES ($1, $2, $3)
             ON CONFLICT DO NOTHING
             RETURNING *`,
            [user_id || 1, word_id, song_id] // Default user_id to 1 for now
        );
        
        res.json({ success: true, saved_word: result.rows[0] });
    } catch (error) {
        console.error('Error saving word:', error);
        res.status(500).json({ success: false, error: 'Failed to save word' });
    }
});

/**
 * GET /api/words/saved - Get user's saved words
 */
router.get('/words/saved', async (req, res) => {
    try {
        const { user_id } = req.query;
        
        const result = await db.query(
            `SELECT 
                usw.id,
                wt.word,
                wt.translation,
                wt.source_language,
                s.title as song_title,
                usw.saved_at
             FROM user_saved_words usw
             JOIN word_translations wt ON usw.word_id = wt.id
             LEFT JOIN songs s ON usw.song_id = s.id
             WHERE usw.user_id = $1
             ORDER BY usw.saved_at DESC`,
            [user_id || 1]
        );
        
        res.json({ success: true, words: result.rows });
    } catch (error) {
        console.error('Error fetching saved words:', error);
        res.status(500).json({ success: false, error: 'Failed to fetch saved words' });
    }
});

/**
 * GET /api/spotify/track/:trackId - Get Spotify track info
 */
router.get('/spotify/track/:trackId', async (req, res) => {
    try {
        const { trackId } = req.params;
        const trackInfo = await spotifyService.getTrackInfo(trackId);
        res.json({ success: true, track: trackInfo });
    } catch (error) {
        console.error('Error fetching Spotify track:', error);
        res.status(500).json({ success: false, error: 'Failed to fetch track info' });
    }
});

/**
 * GET /api/translation/usage - Get DeepL API usage stats
 */
router.get('/translation/usage', async (req, res) => {
    try {
        const usage = await translationService.getUsage();
        res.json({ success: true, usage });
    } catch (error) {
        console.error('Error fetching usage:', error);
        res.status(500).json({ success: false, error: 'Failed to fetch usage' });
    }
});

module.exports = router;